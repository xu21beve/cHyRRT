# cHyRRT
A C++ hybrid rapidly-exploring random tree motion planner, compatible with OMPL and ROS 2 Humble.

<p align="center">
    <img width="100px" height="20px" src="https://img.shields.io/badge/Ubuntu-22.04-orange?logo=Ubuntu&Ubuntu-22.04"
        alt="ubuntu" />
    <img width="100px" height="20px" src="https://img.shields.io/badge/ROS-humble-blue?logo=ROS&ROS=humble" alt="ROS" />
</p>

# Hybrid Rapidly-Exploring Random Trees (HyRRT)

**Motion Planning** is a computational problem that involves finding a sequence of valid configurations to move the robot from the source to the destination. 

This repository provides the implementation of **HyRRT** in C++, compatible with OMPL and ROS 2 Humble. Vertices are implemented as the datatype [ompl::base::State *](https://ompl.kavrakilab.org/classompl_1_1base_1_1State.html) and edges as vectors of the same datatype. The theory analysis of HyRRT can be found at [N. Wang and R. G. Sanfelice](https://ieeexplore.ieee.org/document/9992444). Furthermore, we provide a [MATLAB](https://github.com/HybridSystemsLab/hybridRRT) version, without compatibility with OMPL and ROS.

**Your stars, forks and PRs are welcome!**

## Contents
- [Quick Start](#0)
- [Document](#1)
- [Acknowledgments](#2)
- [License](#3)
- [Maintenance](#4)

## <span id="0">0. Quick Start

*Tested on ubuntu 22.04.3 LTS with ROS Humble.*

1. Install [OMPL](https://ompl.kavrakilab.org/installation.html).

2. Install git.
    ```bash
    sudo apt install git
    ```

3. Install [ROS 2](https://docs.ros.org/en/humble/Installation.html) (Humble recommended, but later versions like Iron may also work.)

4. Clone the reposity.
    ```bash
    git clone https://github.com/xu21beve/cHyRRT.git
    ```


5. Setup CMake Build Directory
  **Note: 
   Open your terminal and navigate to the root folder of this repository. Then, create a new directory called 'Build' and set it as your build directory using CMake. You can do this using the following commands:
   ```
   cd <path-to-your-root-directory>
   mkdir Build
   cd Build
   cmake ..
   ```

2. Build the Project

   Once the CMake files have been generated in the `Build` directory, you can compile all the source files into executables using the `make` command:
   ```
   make
   ```

3. Run the Executables

   Now, you can run the generated executable files located in the `Build/test` folder. You can do this using the following commands:

   - For the Bouncing Ball test, navigate to the project root directory and execute the `bouncing_ball` executable as follows:
     ```
     cd ..
     ./Build/test/bouncing_ball
     ```

   - For the multicopter example, execute the `multicopter` executable as follows:
     ```
     ./Build/test/multicopter
     ```

    > NOTE: Modifying launch files may not have any effect, because they are regenerated by a Python script based on `src/user_config/user_config.yaml` when you run `main.sh`. Therefore, you should modify configurations in `user_config.yaml` instead of launch files.

***Optional:***

7. Use ROS RViz2 to visualize the path.

  - For the bouncing ball or multicopter examples:
    ```
     ./Build/test/visualize
    ```

    ***Include different version for different Operating Systems...***

## 1. <span id="1">Document

The overall file structure is shown below.
```
/root_directory
├── HyRRT.h
├── yourOtherFiles.cpp
└── src
    ├── HyRRT.cpp
    └── yourSrcFiles.cpp
```

For more information about the project usage, please refer to the following table.

| Required | Name | Description |
|:----:|:----:|:----:|
|Yes| maxInputValue_ | Vector of maximum input values (std::vector<double>)
|Yes| minInputValue_ | Vector of minimum input values (std::vector<double>)
|Yes| Tm_ | The maximum flow time for a given flow propagation step. (double)
|Yes| flowStepLength_ | The flow time for a given integration step, within a flow propagation step. (double)
|No| goalTolerance_ | The distance tolerance from the goal state for a state to be regarded as a valid final state. Default is .1 (double)
|Yes| jumpSet_ | Function that returns true if a state is in the jump set, and false if not. (std::function<bool(ompl::base::State *)>)
|Yes| flowSet_ | Function that returns true if a state is in the flow set, and false if not. (std::function<bool(ompl::base::State *)>)
|No| unsafeSet_ | Function that returns true if a state is in the unsafe set, and false if not. (std::function<bool(ompl::base::State )>)
|No| distanceFunc_ | Function that computes distance between states, default is Euclidean distance. (std::function<double(ompl::base::State *, ompl::base::State *)>)
|Yes| jumpPropagation_ | Jump map for propagating a state once. (std::function<ompl::base::State *(ompl::base::State *x_cur, double u, ompl::base::State *x_new)>
|Yes| flowPropagation_ | Flow map for propagating a state over the given flow time. (std::function<base::State *(std::vector<double> input, ompl::base::State *x_cur, double Tm_rand, ompl::base::State *x_new)>)
|No| collisionChecker_ | Function that returns true and modifies the state if collides into the obstacleSet. Default is point-by-point collision checking using the jump set. Refer to **HyRRT.h** for method signature. 

## <span id="2">02. Acknowledgments
* Our robot and world models are from [
Dataset-of-Gazebo-Worlds-Models-and-Maps](https://github.com/mlherd/Dataset-of-Gazebo-Worlds-Models-and-Maps) and [
aws-robomaker-small-warehouse-world](https://github.com/aws-robotics/aws-robomaker-small-warehouse-world). Thanks for these open source models sincerely.

* A ROS costmap plugin for [dynamicvoronoi](http://www2.informatik.uni-freiburg.de/~lau/dynamicvoronoi/) presented by Boris Lau.

## <span id="3">03. License

The source code is released under [MIT](https://www.mit.edu/~amini/LICENSE.md) license.

## <span id="4">04. Maintenance

Feel free to contact us if you have any question.
